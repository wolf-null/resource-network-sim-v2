

#### Using network builders

Network builder classes are the code routines which simplifies generation and alteration of network's **consistence** (the types of nodes in the net) and **structure** (the connections between the nodes). It implements an easy-to-use tools to build-up appropriate net for the research.

Base class of all network builder is stored in lib/NetworkBuilder.py. You don't really need to import or alter it unless you're writing your own builder. All already implemented builders are stored in <u>lib/NetworkBuilders</u> directory.

There are four already implemented network builders yet:

* BuildCompleteGraph | Builds all-to-all connected graph
* BuildParametricalGraph | Builds a graph with given linkage structure
* DropoutDesaturate | Destroys a certain % of output (!) connections (amount is rounded). Not recommended.
* DropoutLimited | For each node destroys some connections near or equal to selected dropout%

Classes started with "Build" initializes both nodes and it's connections whereas classes started with "Dropout" alters only already built networks. Each NetworkBuilder is set up by it's constructor. Building is started with NetworkBuilder.build(n) method, where n is how many nodes to be in the network. Method build() returns the generated net hold by the class Bus.

For instance, one can generate all-to-all graph with 10 nodes all connected to one another:

```python
from lib.NetworkBuilders.BuildCompleteGraph import BuildCompleteGraph
from lib.NetworkBuilders.DropoutLimited import DropoutLimited
# We will need the latter later class

network = BuildCompleteGraph().build(10)
```

Finally, one can see the result of the operations by printing histogram of th number of connections, by the following line:

```python
print(network.graph_statistics_dict())
# Output: {9: 10}
```

It returns a python dict where keys are for the number of connections and values are for the number of nodes with according connection amount. All-to-all graph with 10 nodes, where each node has 9 connections (key) and there are 10 (value) such nodes in the net

Now, lets shake this graph and take out random ~50% of the connections from it

```python
dropouted_network = DropoutLimited(dropout=0.5).build(network)
# Output: [DropoutLimited]: 23 links dropped, which is 51.111% of initial value. The goal was 50.0%

print(network.graph_statistics_dict())
# Output: {4: 4, 3: 1, 5: 5}
```

Since the taken away connections are selected randomly, there are some nodes with higher and lower number of connections: 4 nodes has 4 links; one node linked to 3 other nodes, and 5 nodes has 5 connections. Why is that? We might expect each node to lose 50% of nodes and all to have 5 connections. Not bug but a feature! There is two with a half answers for such a behavior:

1.Since we study big networks one have no reason to generate a network split into two separated, non-interconnected subnets. This is why the algorithm prevents disconnections which will cause violation of graph integrity (integrity means that one can walk from any node to any other node in some way)

2. If there are nodes with a various number of connections, and two such nodes are linked to each other, One will have an asymmetrical situation, where one can't drop the connection between them without dropping connections from a lesser-connected node without decreasing it's number of links more than you would need it.
3. This is why, DropoutLimited decrease number of connection to a suboptimal minimum, where percent of destroyed links for each node is nearly close (or equal) to the <dropout> parameter, but never more than that.

One can also build up a "stacked" builder and using it multiple times for different node amounts, as follows:

```python
from lib.NetworkBuilders.BuildCompleteGraph import BuildCompleteGraph
from lib.NetworkBuilders.DropoutLimited import DropoutLimited

stacked_network_builder = DropoutLimited(BuildCompleteGraph(), dropout=0.5)
# If NetworkBuilder constructor receives an instance of another NetworkBuilder class as the first argument,
# the former will transform the network generated by the latter.

network = stacked_network_builder.build(100)
# The build() function will always return another new network

print(network.graph_statistics_dict())
```

###### BuildParametricalGraph example

Another neat example display the BuildParametricalGraph. It allows to build a graph with the structure specified.

This NetworkBuilder Generates network with amount_of_nodes with defined interconnection_structure, where not more than goal_error nodes are out of the structure (see below). If goal_error is unspecified it is set to 0.

Interconnection_structure have form of a dict: {link_amount:prob, link_amount:prob, ...},
where link_amount is a number of connection and prob is the probability of it's emerging in the net

After the generation phase (encapsulated for user, but may long for indefinite time - not solved yet),
The algorithm checks total_error = |k'th_node_connections - k'th_node_expected_connections| and if
total_error <= goal_error it stops the generation process and passes back to build() procedure (returns the net)

```python
from lib.NetworkBuilders.BuildParametricalGraph import BuildParametricalGraph

goal = {2:0.2, 3:0.2, 4:0.6}
# Will work right the same way as the output of Bus.graph_statistics_dict()

network_generator = BuildParametricalGraph(structure=goal, goal_error=1)
#   One can't always generate the node completely identical to the parameters given.
#   Can't always make all nodes to have the exact number of links, some of them
#   might have lesser links. The <goal_error> parameter shows acceptable lack of links in the net """

n_nodes = 1000
network = network_generator.build(n_nodes)

# One can normalize net statistics to percentage to see it same way as the goal structure:
result = network.graph_statistics_dict()
norm_result = {r: result[r]/n_nodes for r in result}

print("\nGoal: ", goal)
print("\nResult: ", norm_result)

# Output: 
# Goal:  {2: 0.2, 3: 0.2, 4: 0.6}
# Result:  {2: 0.2, 3: 0.2, 4: 0.6}
```



One can also stack a dropout to ensure that DropoutLimited method is pretty accurate in saving the graph statistical structure (if to acknowledge that both graph precise structure and taken out links are random):

```python
from lib.NetworkBuilders.BuildParametricalGraph import BuildParametricalGraph
from lib.NetworkBuilders.DropoutLimited import DropoutLimited

goal_structure = {2:0.2, 3:0.2, 4:0.6}
goal_error = 1

network_generator = DropoutLimited(BuildParametricalGraph(structure=goal_structure, goal_error=goal_error), dropout=0.5)

n_nodes = 100
network = network_generator.build(n_nodes)

# Normalize:
result = network.graph_statistics_dict()
norm_result = {r: result[r]/n_nodes for r in result}

print("\nGoal: ", goal)
print("\nResult: ", norm_result)

# Output:
# [DropoutLimited]: 694 links dropped, which is 40.824% of initial value. The goal was 50.0%
# Goal:  {2: 0.2, 3: 0.2, 4: 0.6}
# Result:  {1: 0.155, 2: 0.615,  3: 0.229, 4: 0.001}
```

One can see that the proportion is qualitatively similar. In increases with increasing number of nodes